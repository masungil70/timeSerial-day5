# Index (시간 인덱스)

시계열 데이터 분석에서 **인덱스(Index)** 는 단순한 행 번호가 아니라, 데이터의 **'정체성'** 이자 **'이정표'** 역할을 합니다.

## 1. 특징

1. 시계열 데이터의 기준 축
2. Pandas에서는 DatetimeIndex 사용

---

### 1. 시계열 데이터의 기준 축 (The Reference Axis)

시계열 데이터에서 인덱스는 단순히 데이터를 나열하는 순서가 아니라, **'언제' 발생한 일인지**를 나타내는 절대적인 기준선입니다.

* **데이터의 정렬:** 시간은 거스를 수 없기 때문에, 인덱스를 기준으로 데이터를 오름차순 정렬하면 흐름을 한눈에 파악할 수 있습니다.
* **연속성과 간격:** 데이터 사이의 시간 간격(1분 단위, 1일 단위 등)을 확인하여 결측치(데이터가 빈 곳)를 찾는 기준이 됩니다.
* **슬라이싱(Slicing):** "2026년 1월부터 3월까지의 데이터만 가져와"와 같은 복잡한 추출을 인덱스 덕분에 아주 쉽게 할 수 있습니다.

#### 예시 (일반 데이터 vs 시계열 데이터)

* **일반 데이터:** 인덱스가 `[0, 1, 2]` — 단순한 순서일 뿐 의미가 없음.
* **시계열 데이터:** 인덱스가 `['2026-01-01', '2026-01-02']` — 데이터의 발생 시점이라는 강력한 정보 포함.

---

### 2. Pandas의 DatetimeIndex

Pandas는 날짜와 시간을 효율적으로 다루기 위해 전용 인덱스 객체인 **`DatetimeIndex`** 를 제공합니다.

* **특수 속성 제공:** `.year`, `.month`, `.day`, `.day_name()`(요일) 등 시간 관련 정보를 함수 호출 없이 속성만으로 바로 뽑아낼 수 있습니다.
* **리샘플링(Resampling):** 일 단위 데이터를 월 단위로 합치거나(Upsampling), 분 단위 데이터를 시간 단위로 평균 내는(Downsampling) 작업이 가능합니다.
* **유연한 문자열 인식:** `'2026-01-01'`, `'2026/01/01'`, `'Jan 1, 2026'` 등 다양한 형태의 문자열을 자동으로 날짜로 인식해 변환해 줍니다.

#### DatetimeIndex가 제공하는 기능

| 기능 | 설명 |
| ----- | ---------------------------- |
| 날짜 연산 | 하루 더하기, 차이 계산 |
| 시간 추출 | year, month, day, hour |
| 부분 선택 | '2026-01', '2026-01-15' |
| 리샘플링 | resample('M'), resample('H') |
| 타임존 | tz_localize, tz_convert |

---

### 3. DatetimeIndex 예제 코드

Pandas를 활용해 `DatetimeIndex`를 만들고 활용하는 간단한 예제입니다.

파일명 : step2/datetime_index.py

```python
import pandas as pd

# 1. 데이터 생성 (날짜 문자열 리스트)
dates = ['2026-01-01', '2026-01-02', '2026-01-03', '2026-01-07']
data = [100, 150, 120, 200]

# 2. DatetimeIndex로 변환하며 데이터프레임 생성
df = pd.DataFrame(data, index=pd.to_datetime(dates), columns=['Price'])

print("--- 생성된 데이터프레임 ---")
print(df)

# 3. DatetimeIndex의 강력한 기능들
print(f"\n인덱스의 연도 정보: {df.index.year.tolist()}")
print(f"인덱스의 요일 정보: {df.index.day_name().tolist()}")

# 4. 특정 기간 슬라이싱 (2026년 1월 1일부터 2일까지)
print("\n--- 2026년 1월 1일부터 2일까지  데이터 ---")
print(df.loc['2026-01-01':'2026-01-02'])

```

실행

```PowerShell
python .\datetime_index.py
```

실행결과

```PowerShell
--- 생성된 데이터프레임 ---
            Price
2026-01-01    100
2026-01-02    150
2026-01-03    120
2026-01-07    200

인덱스의 연도 정보: [2026, 2026, 2026, 2026]
인덱스의 요일 정보: ['Wednesday', 'Thursday', 'Friday', 'Tuesday']

--- 2026년 1월 1일부터 2일까지 데이터 ---
            Price
2026-01-01    100
2026-01-02    150
```

---

## 2. 시계열 데이터에서 “시간 인덱스”가 중요한 이유

### 핵심 이유 5가지

1. **정렬 기준**

   * 시간 순서가 보장됨
2. **슬라이싱**

   * 특정 날짜/시간 구간 조회 가능
3. **리샘플링**

   * 일 → 월, 분 → 시간 변환
4. **시계열 연산**

   * 이동 평균, 누적 합
5. **모델 입력 기준**

   * LSTM, ARIMA는 시간 순서 필수

---

### DatetimeIndex 생성 방법(datetimeIndex 폴더 참조)

파일명 : datetimeIndex/date_range.py

🔹 방법 1: `pd.date_range()` (가장 많이 사용)

```python
import pandas as pd

dates = pd.date_range(
    start="2026-01-01",   # 시작 날짜
    periods=5,            # 생성할 날짜의 개수
    freq="d"              # 간격 (d: 일 단위)
)

print(dates)
```

### 결과

```text
DatetimeIndex(['2026-01-01', '2026-01-02', '2026-01-03',
               '2026-01-04', '2026-01-05'],
              dtype='datetime64[ns]', freq='D')
```

---

### freq 인자 종류

freq 값만 바꾸면 다양한 주기의 시계열 데이터를 순식간에 만들 수 있습니다.

|설정값|의미|결과 예시 (시작일: 1/1)|
|---|---|---|
|"D"|일 단위 (Day)|"1/1, 1/2, 1/3..."|
|"B"|평일 단위 (Business Day)|토/일 제외하고 생성|
|"H"|시간 단위 (Hour)|"1/1 00:00, 1/1 01:00..."|
|"ME"|월말 단위 (Month End)|"1/31, 2/28, 3/31..."|
|"W"|주 단위 (Week)|일요일마다 생성|

---

### 🔹 방법 2: to_datetime() : 문자열 → DatetimeIndex 변환

```python
dates = pd.to_datetime([
    "2026-01-01",
    "2026-01-02",
    "2026-01-03"
])
```

---

### 🔹 방법 3: DataFrame에서 변환

```python
# 문자열 날짜 → datetime 타입으로 변환합니다
df["date"] = pd.to_datetime(df["date"])
# date 컬럼을 Index(시간 인덱스)로 설정합니다
# 별도의 변수에 저장(df = ...)하지 않아도 원본 df 자체를 즉시 수정하라는 명령어입니다.
df.set_index("date", inplace=True)

# 위 두 라인이 실행되면 df는 시계열 데이터프레임(Time Series DataFrame)으로 변환됩니다 
```

---

### DatetimeIndex를 가진 시계열 데이터 생성 예제

#### 예제 : 기본 시계열 데이터

파일명 : day1/step1/time_series.py

```python
import pandas as pd
import numpy as np

dates = pd.date_range(
    "2026-01-01",    # 시작 날짜: 2026년 1월 1일부터 시작
    periods=7,       # 생성 개수: 총 7개의 날짜를 생성
    freq="D"         # 주기(Frequency): 'D'는 일(Day) 단위를 의미 (매일매일)
)
# 결과: 2026-01-01, 2026-01-02, ..., 2026-01-07 까지의 인덱스 생성

# 2. 실제 데이터(수치) 생성
# np.random.randint는 정해진 범위 내에서 무작위 정수를 생성합니다.
values = np.random.randint(
    10,              # 최소값: 10부터 시작 (포함)
    50,              # 최대값: 50 직전까지 (49까지 포함)
    size=7           # 개수: 위에서 만든 날짜 개수와 동일하게 7개 생성
)
# 결과: [24, 45, 12, 38, ...] 같은 형태의 7개 정수 배열 생성

# 3. Pandas Series 객체 생성
# 데이터(values)와 인덱스(index)를 합쳐서 하나의 시계열 데이터를 완성합니다.
ts = pd.Series(
    values,          # Series의 본체 데이터 (무작위 정수 7개)
    index=dates      # 각 데이터에 대응하는 날짜 인덱스 부여
)

# 생성된 시계열 데이터 확인
print(ts)
```

---

### 🔹 날짜 기반 슬라이싱

슬라이싱이란? 데이터의 특정 조건에 맞는 구간을 통째로 잘라내는 것을 의미합니다.

```python
# --- 1. 특정 날짜 Slicing
value = ts['2026-01-03']
print(f"\n2026-01-03의 값은 == {value}\n")

# 날짜 범위
# --- 2. 특정 기간 데이터 추출 (Slicing) ---
# Pandas Series에서는 날짜 문자열을 사용하여 시작:끝 범위를 지정할 수 있습니다.
# "2026-01-02"부터 "2026-01-05"까지의 데이터를 잘라냅니다. (시작과 끝 날짜 모두 포함)
print(ts["2026-01-02":"2026-01-05"])

# --- 3. 추출된 데이터의 인덱스를 활용한 반복문 (Looping) ---
# ts["2026-01-02":"2026-01-05"].index는 추출된 범위의 '날짜(DatetimeIndex)'들만 모아둔 것입니다.
for d in ts["2026-01-02":"2026-01-05"].index:
    # d는 현재 순회 중인 '날짜 객체(Timestamp)'입니다.
    # ts[d]는 원본 Series에서 해당 날짜(d)에 매칭되는 '값(Value)'을 가져옵니다.
    print(f"{d} -> {ts[d]}")
    print('-' * 30)

```

#### 일반 인덱스(정수) 슬라이싱의 한계

일반 인덱스에서 슬라이싱을 하려면, 내가 찾고 싶은 데이터가 **'몇 번째 행'** 에 있는지 정확히 알아야 합니다.

* **코드:**
  * `ts.iloc[2]` (2번행을 가져와)
  * `ts.iloc[0:2]` (0번부터 2번 행까지 가져와)
* **문제점:** "2026년 1월 데이터가 몇 번 행부터 시작하더라?"를 사람이 직접 세거나 찾아내야 합니다. 데이터가 수만 개라면 많은 시간이 걸립니다.

---

#### 날짜 인덱스 슬라이싱의 '지능형' 기능

날짜를 인덱스로 잡으면, 판다스는 내부적으로 날짜의 **선후 관계와 논리**를 이해합니다.

| 특징 | 일반 인덱스 슬라이싱 (`iloc`) | 날짜 인덱스 슬라이싱 (`loc`) |
| --- | --- | --- |
| **기준** | **순서(위치)** 기반 | **의미(값)** 기반 |
| **사용 예시** | `ts.iloc[100:200]` | `ts.loc['2026-01-01':'2026-01-31']` |
| **유연성** | 데이터가 추가/삭제되면 인덱스 번호가 꼬일 수 있음 | 날짜만 맞으면 어디에 있든 정확히 가져옴 |
| **부분 일치** | 불가능 (정확한 번호 필요) | **가능** ('2026'만 입력해도 1년치 추출) |

---

### 3. 결정적인 차이: "비연속적 데이터"

만약 데이터에서 **주말 데이터**만 뽑고 싶다고 가정해 봅시다.

* **일반 인덱스:** 토요일이 5번, 6번, 12번, 13번... 인지 일일이 확인해서 번호를 리스트로 넘겨줘야 합니다.
* **날짜 인덱스:** `ts.index.weekday` 속성을 활용해 "요일이 5 또는 6인 것"을 단 한 줄로 슬라이싱하거나 필터링할 수 있습니다.

---

### 🔹 연/월/일 정보 추출

```python
# 1. 인덱스에서 '연도(Year)' 정보만 추출
# ts.index가 DatetimeIndex일 때만 사용 가능합니다.
# 모든 행의 연도 데이터를 정수(int) 형태의 배열로 반환합니다.
print(ts.index.year) 
# 결과 예시: Int64Index([2026, 2026, ..., 2026], dtype='int64')

# 2. 인덱스에서 '월(Month)' 정보만 추출
# 1월은 1, 12월은 12로 표시되는 정수 데이터를 반환합니다.
print(ts.index.month)
# 결과 예시: Int64Index([1, 1, ..., 1], dtype='int64') (모두 1월이므로)

# 3. 인덱스에서 '일(Day)' 정보만 추출
# 해당 날짜의 일자 데이터를 정수 형태로 반환합니다.
print(ts.index.day)
# 결과 예시: Int64Index([1, 2, 3, 4, 5, 6, 7], dtype='int64')
```

---

### 🔹 리샘플링 (시간 단위 변경)

리샘플링은 시계열 데이터의 **빈도(Frequency)를 변경**하는 작업입니다.

* **다운샘플링(Down-sampling):** 고빈도(일별) 데이터를 저빈도(주별, 월별)로 합치는 과정입니다.
* **업샘플링(Up-sampling):** 저빈도(월별) 데이터를 고빈도(일별)로 늘리는 과정입니다. (결측치 채우기 등이 필요함)

### 일 → 주 평균 예제

```python
import pandas as pd

# --- 시계열 리샘플링 및 주간 평균 계산 ---

# 1. ts.resample("W"): 데이터를 '주(Weekly)' 단위로 그룹화합니다.
# "W"는 일요일을 기준으로 한 주를 묶는 옵션입니다.
# 이 단계까지만 실행하면 그룹화된 상태(Resampler 객체)이며, 실제 값은 계산되지 않습니다.
resampled_data = ts.resample("W")

# 2. .mean(): 그룹화된 각 주차 데이터들의 '산술 평균'을 계산합니다.
# 예를 들어, 한 주에 포함된 7일치 데이터의 합을 7로 나눈 값이 해당 주의 대표값이 됩니다.
weekly_mean = resampled_data.mean()

# 3. 결과 출력
# 인덱스는 각 주의 마지막 날(보통 일요일)로 표시되며, 값은 그 주의 평균값이 출력됩니다.
print(weekly_mean)

```

---

### `resample` 옵션들

| 옵션 코드 | 의미 | 설명 |
| --- | --- | --- |
| **"W"** | Weekly | 일요일 시작 기준 주간 집계 |
| **"M"** | Monthly | 월말 기준 월간 집계 |
| **"MS"** | Month Start | 월초 기준 월간 집계 |
| **"Q"** | Quarterly | 분기별 집계 |
| **"H"** | Hourly | 시간별 집계 |

---

`.mean()` 자리에 다른 함수를 써서 다양한 통계를 낼 수 있습니다.

* `ts.resample("W").sum()` : 주간 **합계**
* `ts.resample("W").max()` : 주간 **최댓값**
* `ts.resample("W").ohlc()` : 주간 **시가/고가/저가/종가** (금융 분석용)

### 🔹 이동 평균 계산

```python
import pandas as pd

# --- 3일 이동 평균(Rolling Mean) 계산 ---

# 1. ts.rolling(window=3): 
# 현재 데이터를 기준으로 '윈도우(창문)'라는 크기 3의 구간을 설정합니다.
# 즉, [현재 행, 바로 직전 행, 그 전 행] 이렇게 3개씩 묶어서 볼 준비를 합니다.
rolling_obj = ts.rolling(window=3)

# 2. .mean():
# 위에서 설정한 윈도우(3개 데이터) 안에 들어온 값들의 '평균'을 계산합니다.
# 이 과정을 한 칸씩 아래로 내려가며 반복하기 때문에 '이동' 평균이라고 부릅니다.
rolling_avg = rolling_obj.mean()

# 3. 결과 출력
print(rolling_avg)

```

결과 
```PowerShell
2026-01-01          NaN
2026-01-02          NaN
2026-01-03    26.666667
2026-01-04    20.666667
2026-01-05    27.333333
2026-01-06    23.666667
2026-01-07    30.333333
Freq: D, dtype: float64
```
---

### 🔍 계산 원리

이동 평균은 **최소 윈도우 크기(여기서는 3)** 만큼의 데이터가 쌓여야 계산이 가능합니다.

* **1일차:** 앞의 데이터가 없으므로 평균을 낼 수 없음 → `NaN` (Not a Number)
* **2일차:** 데이터가 2개뿐이므로 3개를 채우지 못함 → `NaN`
* **3일차:** 1일, 2일, 3일치 데이터가 모임 → **첫 번째 평균값 계산 완료**
* **4일차:** 2일, 3일, 4일치 데이터로 평균 계산 (윈도우가 한 칸 이동)

---

### `min_periods` 옵션

만약 데이터가 3개가 안 되더라도(1개나 2개만 있어도) 평균을 내고 싶다면 `min_periods` 옵션을 사용할 수 있습니다.

```python
# 데이터가 1개만 있어도 일단 평균을 계산함 (NaN을 최소화)
ts.rolling(window=3, min_periods=1).mean()

```

### 이동 평균을 쓰는 이유 (평활화의 효과)

일별 데이터(`ts`)는 무작위 난수(`randint`)라 그래프가 매우 뾰족뾰족할 것입니다. 하지만 `rolling(3).mean()`을 적용하면 그 변동폭이 줄어들면서 **전체적인 흐름이 훨씬 부드러워진 것**을 확인할 수 있습니다.

---

### DatetimeIndex 없을 때 vs 있을 때 차이

---

### ❌ DatetimeIndex 없음

```python
df = pd.DataFrame({
    "date": ["2026-01-01", "2026-01-02"],
    "value": [10, 20]
})
```

* 날짜 연산 ❌
* resample ❌
* 시계열 모델 입력 불가

---

### ⭕ DatetimeIndex 있음

```python
df["date"] = pd.to_datetime(df["date"])
df.set_index("date", inplace=True)
```

* 모든 시계열 기능 가능 ✅

---

### 실무에서 반드시 기억해야 할 핵심 정리

1. **시계열 데이터에서 Index = 시간이다**
2. **Pandas 시계열 분석의 출발점은 DatetimeIndex**
3. **DatetimeIndex 없이는 resample, rolling, 모델링이 불가능**
