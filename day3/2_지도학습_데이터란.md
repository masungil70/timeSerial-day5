# 지도학습 데이터란?

**지도학습(Supervised Learning) 데이터**란 쉽게 말해 **'문제'와 '정답'이 함께 포함된 학습용 데이터**를 의미합니다.

컴퓨터가 스스로 학습할 때, 사람이 옆에서 "이건 고양이 사진이야", "이건 강아지 사진이야"라고 일일이 알려주는 방식과 비슷하기 때문에 '지도(Supervised)'라는 이름이 붙었습니다.

---

## 1. 데이터의 구성 요소

지도학습 데이터는 크게 두 가지 핵심 요소로 나뉩니다.

* **입력 데이터 (Feature, 특성):** 모델이 학습해야 할 대상입니다. (예: 사진, 텍스트, 수치 등)
* **레이블 (Label, 정답):** 입력 데이터에 대해 컴퓨터가 맞춰야 하는 정답입니다. (예: 고양이/강아지 분류, 집값 등)

---

## 2. 지도학습의 작동 원리

1. **훈련(Training):** 컴퓨터에게 '문제(입력)'와 '정답(레이블)'을 쌍으로 보여줍니다.
2. **패턴 발견:** 컴퓨터는 "이런 특징을 가진 데이터는 이런 정답이 나오는구나"라는 규칙을 찾습니다.
3. **예측(Prediction):** 학습이 끝나면 정답이 없는 새로운 데이터를 보여주고, 지금까지 배운 규칙을 바탕으로 정답을 추측합니다.

---

## 3. 주요 활용 사례

데이터의 성격에 따라 크게 두 가지 유형으로 활용됩니다.

| 유형 | 설명 | 예시 |
| --- | --- | --- |
| **분류 (Classification)** | 데이터를 정해진 범주(Category) 중 하나로 나눔 | 스팸 메일 여부 확인, 암 여부 진단 |
| **회귀 (Regression)** | 연속적인 수치값을 예측 | 내일의 기온 예측, 주식 가격 예측 |

---

## 4. 좋은 데이터의 조건

컴퓨터는 학습 데이터에 절대적으로 의존합니다. 따라서 다음과 같은 조건이 중요합니다.

* **정확성:** 정답(레이블)이 틀리면 컴퓨터도 틀리게 배웁니다.
* **다양성:** 다양한 상황의 데이터가 있어야 실전에서도 잘 작동합니다.
* **양:** 데이터가 많을수록 복잡한 패턴을 더 잘 이해할 수 있습니다.

---

## 5. 지도학습 데이터 변환이란?

지도학습(Supervised Learning)에서 **데이터 변환(Data Transformation)** 이란, 모델이 데이터를 더 잘 이해하고 학습 성능을 높일 수 있도록 원본 데이터를 특정 형식이나 범위로 가공하는 과정을 말합니다.

컴퓨터는 사람처럼 문맥을 읽는 것이 아니라 '숫자'로 계산을 하기 때문에, 데이터의 형태를 모델이 선호하는 방식으로 다듬어주는 작업이 필수적입니다.

---

### 1. 데이터 변환이 왜 필요한가요?

* **단위의 불일치 해결:** 예를 들어 '키(cm)'와 '몸무게(kg)'는 숫자의 범위가 다릅니다. 이를 그대로 두면 모델이 숫자가 큰 데이터를 더 중요한 것으로 착각할 수 있습니다.
* **비수치 데이터 처리:** 기계는 '빨강', '파랑' 같은 글자를 이해하지 못하므로 숫자로 바꿔줘야 합니다.
* **이상치(Outlier) 영향 감소:** 너무 튀는 값이 전체 학습을 방해하지 않도록 조절합니다.

---

### 2. 주요 데이터 변환 기법

#### ① 스케일링 (Scaling)

데이터의 수치 범위를 일정하게 맞추는 작업입니다.

* **정규화 (Normalization):** 데이터를 0과 1 사이의 값으로 변환합니다. 주로 데이터의 분포가 일정하지 않을 때 사용합니다.
* **표준화 (Standardization):** 데이터의 평균을 0, 표준편차를 1로 만듭니다. 데이터가 종 모양의 가우시안 분포를 가질 때 유리합니다.

#### ② 인코딩 (Encoding)

범주형 데이터(문자 등)를 수치형 데이터로 변환하는 작업입니다.

* **레이블 인코딩 (Label Encoding):** '사과=0', '배=1'처럼 숫자를 부여합니다. (단, 숫자의 크기가 순위로 오해받을 수 있음)
* **원-핫 인코딩 (One-Hot Encoding):** 해당하는 항목만 1, 나머지는 0으로 표현하는 방식입니다.

#### ③ 차원 축소 (Dimension Reduction)

너무 많은 특성(Feature) 중 중요한 것만 남기거나 합쳐서 계산 효율을 높입니다. 대표적으로 **PCA(주성분 분석)** 가 있습니다.

#### ④ 로그 변환 (Log Transformation)

데이터가 한쪽으로 너무 치우쳐 있을 때, 로그를 취해 분포를 골고루 퍼뜨려 모델의 왜곡을 방지합니다.

---

### 3. 데이터 변환의 흐름

1. **데이터 수집:** 가공되지 않은 Raw 데이터 확보
2. **결측치/이상치 처리:** 비어있는 값이나 잘못된 값 제거
3. **데이터 변환:** 스케일링, 인코딩 등을 적용
4. **모델 학습:** 변환된 데이터를 AI 모델에 입력

> **주의할 점:** 학습 데이터(Train Data)를 기준으로 만든 변환 규칙을 테스트 데이터(Test Data)에도 **동일하게** 적용해야 합니다. 기준이 달라지면 예측 결과가 틀어지기 때문입니다.

---

## 6. 시계열 → 지도학습 데이터 변환

시계열 데이터를 지도학습 데이터로 변환하는 핵심은 **'과거의 데이터($X$)로 미래의 값($y$)을 예측할 수 있는 구조'** 를 만드는 것입니다. 이를 전문 용어로 **윈도잉(Windowing)** 또는 **래그 피처(Lag Features) 생성**이라고 합니다.

---

### 1단계: 데이터 정렬 및 빈 주기 채우기

시계열 데이터는 시간의 흐름이 일정해야 합니다. 데이터 사이의 간격이 일정하지 않다면 학습이 불가능합니다.

* **시간순 정렬:** 데이터를 날짜/시간 순으로 나열합니다.
* **리샘플링(Resampling):** 초 단위 데이터를 분 단위로 합치거나, 비어 있는 날짜를 채워 넣습니다.
* **결측치 처리:** 비어 있는 값은 직전 값으로 채우거나(Forward Fill) 선형 보간법을 사용하여 메꿉니다.

---

### 2단계: 지도학습 구조로 변환 (Sliding Window)

가장 중요한 단계입니다. 한 줄로 나열된 데이터를 **'입력(Features)'** 과 **'타겟(Target)'** 으로 쪼개서 표 형태로 재구성합니다.

* **래그 변수(Lagged Variables):** 과거(이전) 시점의 값을 현재 시점의 입력 변수로 사용합니다.
* **윈도우 크기 설정:** 과거 몇 개의 데이터를 볼 것인지 정합니다. (예: 과거 3일 데이터를 보고 내일 값을 예측)

**[예시: 일별 매출 데이터 변환]**

| 날짜 | 매출(원본) |  |  $X$ (과거 2일 매출) | $y$ (오늘 매출) |
| --- | --- | --- | --- | --- |
| 1일 | 100 | $\rightarrow$ | - | - |
| 2일 | 120 | $\rightarrow$ | (100, 120) | **130** |
| 3일 | 130 | $\rightarrow$ | (120, 130) | **110** |
| 4일 | 110 | $\rightarrow$ | (130, 110) | **150** |

---

### 3단계: 시간 특성(Temporal Features) 추출

단순히 숫자만 넣는 것보다 '시간'이 가진 의미를 숫자로 풀어주면 성능이 훨씬 좋아집니다.

* **날짜 정보 분리:** 연, 월, 일, 요일, 시간 등을 별도 컬럼으로 만듭니다.
* **주기성 반영:** 주말 여부, 공휴일 여부, 분기 정보 등을 추가합니다.
* **통계적 특성(Rolling Window):** 최근 7일간의 평균, 최근 30일간의 표준편차 같은 이동 평균 값을 계산하여 추가합니다.

---

### 4단계: 데이터 스케일링 및 변환

지도학습 모델(특히 딥러닝이나 거리 기반 모델)은 숫자의 크기에 민감합니다.

* **차분(Differencing):** 데이터에 추세가 있다면 '값 자체' 대신 '전날 대비 증감량'으로 변환하여 정상성(Stationarity)을 확보합니다.
* **표준화/정규화:** 모든 입력값을 0~1 사이로 맞춥니다.

---

### 5단계: 시계열 전용 데이터 분할 (Time Series Split)

일반적인 지도학습처럼 데이터를 무작위로 섞으면(Shuffle) 안 됩니다! **미래의 데이터가 과거의 학습에 포함되는 'Data Leakage'** 현상이 발생하기 때문입니다.

* **방식:** 항상 과거 데이터를 훈련(Train)으로, 그 뒤에 오는 미래 데이터를 검증(Test)으로 사용해야 합니다.

---

### 7. 실전에서 쓰이는 주요 변환 기법 요약

| 구분 | 기법 | 설명 |
| --- | --- | --- |
| **수치 변환** | **Scaling** | 데이터 범위를 0~1 사이 등으로 맞춤 (정규화/표준화) |
| **범주 변환** | **Encoding** | '월요일' → 1, '화요일' → 2 혹은 [1, 0, 0...] 형태로 변환 |
| **시계열 변환** | **Lagging** | 과거의 데이터를 현재 행의 새로운 열(Column)로 추가 |
| **분포 변환** | **Log Transform** | 숫자가 너무 들쭉날쭉할 때 로그를 취해 안정화함 |

### 요약

시계열을 지도학습으로 바꾸는 것은 **"어제의 나($t-1$)와 오늘의 나($t$)를 한 줄에 나란히 세워, 내일의 나($t+1$)를 맞히게 만드는 과정"** 입니다.

---
시계열 데이터를 지도 학습(Supervised Learning) 모델에 학습시키기 위해서는, 정지해 있는 일반적인 데이터와 달리 **"시간의 흐름"** 을 데이터 구조에 녹여내야 합니다. 이때 가장 핵심이 되는 기법이 바로 **슬라이딩 윈도우(Sliding Window)** 입니다.

---

## 7. 슬라이딩 윈도우의 기본 개념

슬라이딩 윈도우란, 고정된 크기의 **'창(Window)'** 을 설정하고 이 창을 시간 순서에 따라 한 칸씩 옆으로 밀면서(Sliding) 데이터를 추출하는 방식입니다.

* **입력($X$):** 과거의 연속된 데이터 (Look-back window)
* **출력($y$):** 미래의 예측하고자 하는 데이터 (Target)

---

### 1. 주요 구성 요소 (Hyperparameters)

슬라이딩 윈도우를 설계할 때 결정해야 할 세 가지 핵심 요소가 있습니다.

1. **Window Size (Look-back):** 과거 몇 개의 데이터를 모델의 입력으로 쓸 것인가?
* 예: 지난 24시간의 전력 사용량을 보고 예측하겠다.

2. **Horizon:** 얼마나 먼 미래를 예측할 것인가?
* 예: 1시간 뒤($t+1$)를 예측하겠다.

3. **Stride (Step):** 창을 몇 칸씩 옆으로 밀 것인가?
* 보통은 1칸씩 밀어 모든 연속된 데이터를 학습에 사용합니다.

---

### 2. 데이터 변환 과정 시각화

예를 들어, `[10, 20, 30, 40, 50, 60]`이라는 시계열 데이터가 있고, **Window Size=3, Horizon=1** 이라고 가정해 보겠습니다.

| 단계 | 현재 윈도우 범위 (입력) | 다음 데이터 (정답) |
| --- | --- | --- |
| **Step 1** | `[10, 20, 30]` | **40** |
| **Step 2** | `[20, 30, 40]` | **50** |
| **Step 3** | `[30, 40, 50]` | **60** |

예를 들어, `[10, 20, 30, 40, 50, 60]`이라는 시계열 데이터가 있고, **Window Size=3, Horizon=2** 이라고 가정해 보겠습니다.

| 단계 | 현재 윈도우 범위 (입력) | 다음 데이터 (정답) |
| --- | --- | --- |
| **Step 1** | `[10, 20, 30]` | **40, 50** |
| **Step 2** | `[20, 30, 40]` | **50, 60** |

---

### 3. 슬라이딩 윈도우의 장단점

#### 장점

* **데이터 증강(Data Augmentation):** 하나의 시계열 흐름에서 수많은 중첩된 학습 샘플을 생성하여 모델의 학습량을 늘려줍니다.
* **패턴 학습:** 모델이 특정 시점이 아닌, 전후 맥락(Context)을 이해하게 합니다.

#### 단점

* **데이터 중복:** 데이터 샘플 간에 겹치는 부분이 많아져 메모리 사용량이 늘어날 수 있습니다.
* **최근성 편향:** 윈도우 사이즈를 너무 크게 잡으면 아주 오래된 데이터가 현재 예측에 불필요한 노이즈가 될 수 있습니다.

---

### 4. 다중 단계 예측 (Multi-Step Forecasting)

단순히 다음 1시간(타겟 $y$)이 아니라, 다음 3시간(타겟 $y$)을 한꺼번에 예측하고 싶다면 의 크기를 늘리면 됩니다.

* $X$ (입력): $t-23, \dots, t$ (과거 24시간)
* $y$ (출력): $t+1, t+2, t+3$ (미래 3시간)

이런 구조를 통해 모델은 미래의 단기적인 추세까지 한 번에 학습할 수 있게 됩니다.

---

## 8. 예제 시계열 데이터를 학습용 데이터셋으로 변환

2주일간의 1시간 단위 전력 사용량 데이터를 **지도 학습(Supervised Learning)** 용 데이터셋으로 변환하는 핵심은 **"과거의 데이터($X$)를 통해 미래의 데이터($y$)를 예측하는 구조"** 를 만드는 것입니다.

이를 위해 가장 널리 쓰이는 방법은 **슬라이딩 윈도우(Sliding Window)** 기법입니다. 구체적인 절차와 방법은 다음과 같습니다.

---

### 1. 데이터 전처리 (Pre-processing)

변환 전, 데이터의 품질을 높이기 위한 기초 단계입니다.

* **결측치 처리:** 1시간 단위 데이터에서 비어있는 시간대가 있는지 확인하고, 평균값이나 선형 보간법(Interpolation)으로 채웁니다.
* **시간 정보 분해:** `Date` 컬럼에서 '시간(Hour)', '요일(Day of week)' 정보를 추출합니다. 전력 사용량은 시간대와 요일에 따라 패턴이 뚜렷하므로 매우 중요한 피처가 됩니다.
* **스케일링(Scaling):** 모델의 학습 효율을 위해  ~  사이 값으로 정규화(Min-Max Scaling)합니다.

---

### 2. 지도 학습 데이터 변환: 슬라이딩 윈도우

시계열 데이터는 순서가 중요하므로, 일정 크기의 창(Window)을 옆으로 밀어가며 입력값($X$)과 정답값($y$) 쌍을 생성합니다.

#### 윈도우 구성 예시 (Look-back=24, Horizon=1)

만약 **"지난 24시간의 데이터를 보고 다음 1시간을 예측"** 한다면 다음과 같이 구성됩니다.

| 데이터 구성 | 입력 데이터 ($X$, Features) | 정답 데이터 ($y$, Target) |
| --- | --- | --- |
| **1번째 샘플** | 1일차 0시 ~ 23시 전력량 | 2일차 0시 전력량 |
| **2번째 샘플** | 1일차 1시 ~ 2일차 0시 전력량 | 2일차 1시 전력량 |
| **3번째 샘플** | 1일차 2시 ~ 2일차 1시 전력량 | 2일차 2시 전력량 |

> **Tip:** 2주일치 데이터(336시간)를 24시간 윈도우로 변환하면, 약 312개의 학습 샘플을 얻을 수 있습니다.

---

### 3. Python 코드를 활용한 구현 방법(step2 폴더 참조)

Pandas의 `shift()` 함수를 이용하면 매우 간단하게 변환할 수 있습니다.

파일명 : main.py

```python
# 1. 데이터 로드
# 전력 사용량 데이터셋을 불러옵니다.
df = pd.read_csv('./data/power_usage_dataset.csv')
df['Date'] = pd.to_datetime(df['Date'])
df = df.sort_values('Date')

# --- 2. 결측치 처리 (선형 보간법) ---
# 데이터가 가진 '시간적 연속성'을 보장하기 위해 시간축을 재설정하고 보정합니다.
df = df.set_index('Date').resample('h').asfreq() # 비어있는 시간대 생성
df['Usage'] = df['Usage'].interpolate(method='linear') # 선형 보간법 적용
# 시간축을 재설정하고 보정합니다.
df = df.reset_index()

# --- 3. 시간 정보 분해 (Feature Engineering) ---
# 모델이 시간적 패턴을 파악할 수 있도록 '시간'과 '요일' 정보를 추출합니다.
df['hour'] = df['Date'].dt.hour
df['day_of_week'] = df['Date'].dt.dayofweek # 월요일: 0, 일요일: 6

# --- 4. 정규화 (Min-Max Scaling) ---
# 전력 사용량(Usage) 데이터를 0과 1 사이로 변환합니다.
scaler = MinMaxScaler()
df['Usage_scaled'] = scaler.fit_transform(df[['Usage']])

# --- 5. 지도 학습 데이터셋 생성 (Sliding Window) ---
# 예: 과거 3시간 데이터를 feature(X)로 사용
df['t-1'] = df['Usage'].shift(1)
df['t-2'] = df['Usage'].shift(2)
df['t-3'] = df['Usage'].shift(3)

# 과거 24시간의 사용량을 입력(X)으로, 현재 사용량을 정답(y)으로 설정
window_size = 24
X, y = [], []

scaled_data = df['Usage_scaled'].values

for i in range(window_size, len(scaled_data)):
    X.append(scaled_data[i-window_size:i]) # 과거 24시간 데이터
    y.append(scaled_data[i])               # 현재 시점의 정답

X_final = np.array(X)
y_final = np.array(y)

print(f"변환된 데이터 셋 크기: X={X_final.shape}, y={y_final.shape}")

# 별도의 학습용 데이터프레임을 만들어 저장 합니다.
# (X의 각 시점을 컬럼으로, y를 마지막 컬럼으로)
train_df = pd.DataFrame(X_final, columns=[f't-{i}' for i in range(window_size, 0, -1)])
train_df['target_y'] = y_final
train_df.to_csv('./data/processed_power_usage_dataset.csv', index=False)

df.to_csv('./data/power_usage_dataset_output.csv', index=False)


```

---

### 4. 최종 데이터셋 구조 (Table format)

변환이 완료되면 데이터는 아래와 같은 형태의 행렬이 됩니다.

| Timestamp | **Usage ($y$)** | t-1 ($X_1$) | t-2 ($X_2$) | t-3 ($X_3$) |
| --- | --- | --- | --- | --- |
| 2025-06-01 03:00 | **0.64** | 0.6 | 0.71 | 0.82 |
| 2025-06-01 04:00 | **0.6** | 0.64 | 0.6 | 0.71 |
| 2025-06-01 05:00 | **0.6** | 0.06 | 0.64 | 0.6 |

---

### 5. 모델 선택 및 학습

이제 이 데이터를 가지고 다음과 같은 모델에 입력할 수 있습니다.

* **회귀 모델:** XGBoost, LightGBM, Random Forest (표 형식의 데이터에 강함)
* **딥러닝 모델:** LSTM, GRU (순차적 정보 학습에 최적화)
